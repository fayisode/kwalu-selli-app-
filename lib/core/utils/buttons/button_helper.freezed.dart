// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'button_helper.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DefinedButtonType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isWithRightIcon,
    required TResult Function() isWithLeftIcon,
    required TResult Function() isWithNoIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsWithRightIcon value) isWithRightIcon,
    required TResult Function(_IsWithLeftIcon value) isWithLeftIcon,
    required TResult Function(_IsWithNoIcon value) isWithNoIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DefinedButtonTypeCopyWith<$Res> {
  factory $DefinedButtonTypeCopyWith(
          DefinedButtonType value, $Res Function(DefinedButtonType) then) =
      _$DefinedButtonTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$DefinedButtonTypeCopyWithImpl<$Res>
    implements $DefinedButtonTypeCopyWith<$Res> {
  _$DefinedButtonTypeCopyWithImpl(this._value, this._then);

  final DefinedButtonType _value;
  // ignore: unused_field
  final $Res Function(DefinedButtonType) _then;
}

/// @nodoc
abstract class _$$_IsWithRightIconCopyWith<$Res> {
  factory _$$_IsWithRightIconCopyWith(
          _$_IsWithRightIcon value, $Res Function(_$_IsWithRightIcon) then) =
      __$$_IsWithRightIconCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsWithRightIconCopyWithImpl<$Res>
    extends _$DefinedButtonTypeCopyWithImpl<$Res>
    implements _$$_IsWithRightIconCopyWith<$Res> {
  __$$_IsWithRightIconCopyWithImpl(
      _$_IsWithRightIcon _value, $Res Function(_$_IsWithRightIcon) _then)
      : super(_value, (v) => _then(v as _$_IsWithRightIcon));

  @override
  _$_IsWithRightIcon get _value => super._value as _$_IsWithRightIcon;
}

/// @nodoc

class _$_IsWithRightIcon implements _IsWithRightIcon {
  const _$_IsWithRightIcon();

  @override
  String toString() {
    return 'DefinedButtonType.isWithRightIcon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsWithRightIcon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isWithRightIcon,
    required TResult Function() isWithLeftIcon,
    required TResult Function() isWithNoIcon,
  }) {
    return isWithRightIcon();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
  }) {
    return isWithRightIcon?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithRightIcon != null) {
      return isWithRightIcon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsWithRightIcon value) isWithRightIcon,
    required TResult Function(_IsWithLeftIcon value) isWithLeftIcon,
    required TResult Function(_IsWithNoIcon value) isWithNoIcon,
  }) {
    return isWithRightIcon(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
  }) {
    return isWithRightIcon?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithRightIcon != null) {
      return isWithRightIcon(this);
    }
    return orElse();
  }
}

abstract class _IsWithRightIcon implements DefinedButtonType {
  const factory _IsWithRightIcon() = _$_IsWithRightIcon;
}

/// @nodoc
abstract class _$$_IsWithLeftIconCopyWith<$Res> {
  factory _$$_IsWithLeftIconCopyWith(
          _$_IsWithLeftIcon value, $Res Function(_$_IsWithLeftIcon) then) =
      __$$_IsWithLeftIconCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsWithLeftIconCopyWithImpl<$Res>
    extends _$DefinedButtonTypeCopyWithImpl<$Res>
    implements _$$_IsWithLeftIconCopyWith<$Res> {
  __$$_IsWithLeftIconCopyWithImpl(
      _$_IsWithLeftIcon _value, $Res Function(_$_IsWithLeftIcon) _then)
      : super(_value, (v) => _then(v as _$_IsWithLeftIcon));

  @override
  _$_IsWithLeftIcon get _value => super._value as _$_IsWithLeftIcon;
}

/// @nodoc

class _$_IsWithLeftIcon implements _IsWithLeftIcon {
  const _$_IsWithLeftIcon();

  @override
  String toString() {
    return 'DefinedButtonType.isWithLeftIcon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsWithLeftIcon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isWithRightIcon,
    required TResult Function() isWithLeftIcon,
    required TResult Function() isWithNoIcon,
  }) {
    return isWithLeftIcon();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
  }) {
    return isWithLeftIcon?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithLeftIcon != null) {
      return isWithLeftIcon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsWithRightIcon value) isWithRightIcon,
    required TResult Function(_IsWithLeftIcon value) isWithLeftIcon,
    required TResult Function(_IsWithNoIcon value) isWithNoIcon,
  }) {
    return isWithLeftIcon(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
  }) {
    return isWithLeftIcon?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithLeftIcon != null) {
      return isWithLeftIcon(this);
    }
    return orElse();
  }
}

abstract class _IsWithLeftIcon implements DefinedButtonType {
  const factory _IsWithLeftIcon() = _$_IsWithLeftIcon;
}

/// @nodoc
abstract class _$$_IsWithNoIconCopyWith<$Res> {
  factory _$$_IsWithNoIconCopyWith(
          _$_IsWithNoIcon value, $Res Function(_$_IsWithNoIcon) then) =
      __$$_IsWithNoIconCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsWithNoIconCopyWithImpl<$Res>
    extends _$DefinedButtonTypeCopyWithImpl<$Res>
    implements _$$_IsWithNoIconCopyWith<$Res> {
  __$$_IsWithNoIconCopyWithImpl(
      _$_IsWithNoIcon _value, $Res Function(_$_IsWithNoIcon) _then)
      : super(_value, (v) => _then(v as _$_IsWithNoIcon));

  @override
  _$_IsWithNoIcon get _value => super._value as _$_IsWithNoIcon;
}

/// @nodoc

class _$_IsWithNoIcon implements _IsWithNoIcon {
  const _$_IsWithNoIcon();

  @override
  String toString() {
    return 'DefinedButtonType.isWithNoIcon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsWithNoIcon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isWithRightIcon,
    required TResult Function() isWithLeftIcon,
    required TResult Function() isWithNoIcon,
  }) {
    return isWithNoIcon();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
  }) {
    return isWithNoIcon?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isWithRightIcon,
    TResult Function()? isWithLeftIcon,
    TResult Function()? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithNoIcon != null) {
      return isWithNoIcon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsWithRightIcon value) isWithRightIcon,
    required TResult Function(_IsWithLeftIcon value) isWithLeftIcon,
    required TResult Function(_IsWithNoIcon value) isWithNoIcon,
  }) {
    return isWithNoIcon(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
  }) {
    return isWithNoIcon?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsWithRightIcon value)? isWithRightIcon,
    TResult Function(_IsWithLeftIcon value)? isWithLeftIcon,
    TResult Function(_IsWithNoIcon value)? isWithNoIcon,
    required TResult orElse(),
  }) {
    if (isWithNoIcon != null) {
      return isWithNoIcon(this);
    }
    return orElse();
  }
}

abstract class _IsWithNoIcon implements DefinedButtonType {
  const factory _IsWithNoIcon() = _$_IsWithNoIcon;
}

/// @nodoc
mixin _$DefinedButtonSize {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isSmall,
    required TResult Function() isBig,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsSmall value) isSmall,
    required TResult Function(_IsBig value) isBig,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DefinedButtonSizeCopyWith<$Res> {
  factory $DefinedButtonSizeCopyWith(
          DefinedButtonSize value, $Res Function(DefinedButtonSize) then) =
      _$DefinedButtonSizeCopyWithImpl<$Res>;
}

/// @nodoc
class _$DefinedButtonSizeCopyWithImpl<$Res>
    implements $DefinedButtonSizeCopyWith<$Res> {
  _$DefinedButtonSizeCopyWithImpl(this._value, this._then);

  final DefinedButtonSize _value;
  // ignore: unused_field
  final $Res Function(DefinedButtonSize) _then;
}

/// @nodoc
abstract class _$$_IsSmallCopyWith<$Res> {
  factory _$$_IsSmallCopyWith(
          _$_IsSmall value, $Res Function(_$_IsSmall) then) =
      __$$_IsSmallCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsSmallCopyWithImpl<$Res>
    extends _$DefinedButtonSizeCopyWithImpl<$Res>
    implements _$$_IsSmallCopyWith<$Res> {
  __$$_IsSmallCopyWithImpl(_$_IsSmall _value, $Res Function(_$_IsSmall) _then)
      : super(_value, (v) => _then(v as _$_IsSmall));

  @override
  _$_IsSmall get _value => super._value as _$_IsSmall;
}

/// @nodoc

class _$_IsSmall implements _IsSmall {
  const _$_IsSmall();

  @override
  String toString() {
    return 'DefinedButtonSize.isSmall()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsSmall);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isSmall,
    required TResult Function() isBig,
  }) {
    return isSmall();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
  }) {
    return isSmall?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
    required TResult orElse(),
  }) {
    if (isSmall != null) {
      return isSmall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsSmall value) isSmall,
    required TResult Function(_IsBig value) isBig,
  }) {
    return isSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
  }) {
    return isSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
    required TResult orElse(),
  }) {
    if (isSmall != null) {
      return isSmall(this);
    }
    return orElse();
  }
}

abstract class _IsSmall implements DefinedButtonSize {
  const factory _IsSmall() = _$_IsSmall;
}

/// @nodoc
abstract class _$$_IsBigCopyWith<$Res> {
  factory _$$_IsBigCopyWith(_$_IsBig value, $Res Function(_$_IsBig) then) =
      __$$_IsBigCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsBigCopyWithImpl<$Res> extends _$DefinedButtonSizeCopyWithImpl<$Res>
    implements _$$_IsBigCopyWith<$Res> {
  __$$_IsBigCopyWithImpl(_$_IsBig _value, $Res Function(_$_IsBig) _then)
      : super(_value, (v) => _then(v as _$_IsBig));

  @override
  _$_IsBig get _value => super._value as _$_IsBig;
}

/// @nodoc

class _$_IsBig implements _IsBig {
  const _$_IsBig();

  @override
  String toString() {
    return 'DefinedButtonSize.isBig()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsBig);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() isSmall,
    required TResult Function() isBig,
  }) {
    return isBig();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
  }) {
    return isBig?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? isSmall,
    TResult Function()? isBig,
    required TResult orElse(),
  }) {
    if (isBig != null) {
      return isBig();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IsSmall value) isSmall,
    required TResult Function(_IsBig value) isBig,
  }) {
    return isBig(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
  }) {
    return isBig?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IsSmall value)? isSmall,
    TResult Function(_IsBig value)? isBig,
    required TResult orElse(),
  }) {
    if (isBig != null) {
      return isBig(this);
    }
    return orElse();
  }
}

abstract class _IsBig implements DefinedButtonSize {
  const factory _IsBig() = _$_IsBig;
}
